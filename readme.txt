实现思路：
1.使用java底层方法读取文本文件里面的数据信息，一行一行读取数据并且处理数据信息，将读取的数据保存在List<ConferenceEntity>，
  且读取数据的同时叠加sumMinutes，计算所输入的会议总共的分钟数(方便计算会议安排的天数)。最后将数据的list集合和sumMinutes分
  钟总数保持在实体ConferenceInfoEntity中。
2.通过sumMinutes知道了会议所需要的天数，接下来通过天数进行遍历ConferenceInfoEntity中的List<ConferenceEntity>集合，
  先根据早上会议总共分钟数180的条件先排满，之后当早上刚好是180分钟后，添加新对象作为午餐使用。下次遍历集合就进行下午的会议安排
  这样就是先排满早上，在排满下午就行了；
注：先排满早上在排满下午这样的顺序是为了防止会议的流程被打乱，也让调用者不用再进行排序处理；每次遍历集合满足早上和下午的条件都会
添加在新的集合中，并且当前的对象也会在集合中移除掉，防止下次遍历进行污染；根据天数循环，所以最后返回的数据是Map<DayNum,List>,
当集合的size大于一是，说明会议至少要安排两天。
3.将上一步返回好的数据进行格式化处理，根据Map大小进行遍历list进行格式化，处理出来的一条记录为(9:00  45min  XXXX),最后作为数组进行返回；
返回的数据就是最终分组排序和格式化好的数据信息，只需要遍历打印出即可；
注：其实数据格式化的处理可以放在第二步操作，单独抽取出来方式方法之间太耦合，且不容易理解；
4：通过Application的main方法进行遍历打印出来即可；

实现优点：
1.使用到的数据值，都是使用常量进行代替，如果发生变化，主程序不需要修改，只需要常量变化就行(其实这里使用资源文件更好，方便配置)
2.方法之间组织较好，注释清除，代码缩进统一风格
3.以数组的格式返回，可以取得任意一天的会议安排

实现缺点：
1.只是可以根据指定的数据进行了分组排序；
2.分组排序的数组思想没有进行使用，只是单纯用程序进行实现，不好扩展；

改进思路(需要花时间想想):
1.使用更加合理的排列组合算法，进行所有记录数据，筛选-组合-在排序 直接返回可格式化的数据；
2.对于网络会议，开始时间不能大于下午四点和不能晚于下午五点，这种可控的区间会议处理不是很好，而且真实的会议网络会议的可控时间有时候是下午，
  也有时候是早上，区间的范围也是可控的；
3.会议的时间格式输出，可以输入开始时间和结束时间，并且输入是哪天的会议安排。所以这里还可以传入从哪天开始会议，进行数据输入，更加直观；
4.会议和参会人员和会议室进行关联，对会议人员和会议室进行管理；
5.制作app，对会议开始时间之前一刻钟推送提醒会议参会人员，输入会议时间、会议内容、持续时间和会议地点；
6.后三条只是做的过程之中遐想的，作为底层的逻辑实现固然重要，但是面向使用者才是目的。